import sys
import os
import argparse
import torch
import torchaudio
import traceback
from pathlib import Path

# Add the temp_ace_step directory to sys.path
sys.path.append(os.path.join(os.path.dirname(__file__), 'temp_ace_step'))

# Add local FFMPEG bin to PATH
ffmpeg_bin = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "libs", "ffmpeg_bin")
if os.path.exists(ffmpeg_bin):
    os.environ["PATH"] = ffmpeg_bin + os.pathsep + os.environ["PATH"]
    # Also add for DLL search path on Python 3.8+
    if hasattr(os, 'add_dll_directory'):
        try:
            os.add_dll_directory(ffmpeg_bin)
        except Exception:
            pass

# Set stdout encoding to utf-8
if sys.stdout:
    sys.stdout.reconfigure(encoding='utf-8')

try:
    if hasattr(torchaudio, "set_audio_backend"):
        torchaudio.set_audio_backend("soundfile")
        print("Set torchaudio backend to soundfile")
except Exception as e:
    print(f"Failed to set backend: {e}")

try:
    from acestep.handler import AceStepHandler
except ImportError as e:
    print(f"Error importing AceStepHandler: {e}")
    sys.exit(1)

def separate_audio(input_path, output_dir, device_id=0):
    """
    Separates audio into vocals and instrumental tracks using ACE-STEP v1.5 generative editing.
    """
    input_path = Path(input_path)
    output_dir = Path(output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)

    print(f"Initializing ACE-STEP Handler (v1.5)...")
    
    try:
        handler = AceStepHandler()
        
        # Setup paths for initialization
        project_root = os.path.join(os.path.dirname(__file__), "temp_ace_step")
        config_path = "acestep-v15-turbo"
        
        # Initialize service
        status, success = handler.initialize_service(
            project_root=project_root,
            config_path=config_path,
            device="cuda" if torch.cuda.is_available() else "cpu",
        )
        
        if not success:
            print(f"Failed to initialize service: {status}")
            return
            
        print("Service initialized successfully.")
            
    except Exception as e:
        print(f"Exception during initialization: {e}")
        traceback.print_exc()
        return

    print(f"Processing: {input_path}")

    def generate_and_save(prompt, filename):
        print(f"Generating {filename} with prompt: '{prompt}'...")
        try:
            # Using 'repaint' task for separation/editing
            result = handler.generate_music(
                captions=prompt,
                src_audio=str(input_path),
                task_type="repaint",
                lyrics="",
                inference_steps=50,
                guidance_scale=7.0,
                audio_duration=0, # Auto-detect from source
            )
            
            if result.get('success'):
                audios = result.get('audios', [])
                if audios:
                    # Save the first audio result
                    audio_data = audios[0]
                    tensor = audio_data['tensor']
                    sample_rate = audio_data['sample_rate']
                    
                    save_path = output_dir / filename
                    
                    # Ensure tensor is 2D [channels, samples]
                    if tensor.dim() == 1:
                        tensor = tensor.unsqueeze(0)
                        
                    # Save with soundfile (channels last expected by some, but soundfile handles it based on shape or transpose)
                    # soundfile expects [samples, channels]. Tensor is [channels, samples].
                    import soundfile as sf
                    audio_np = tensor.transpose(0, 1).numpy()
                    sf.write(str(save_path), audio_np, sample_rate)
                    print(f"Saved to: {save_path}")
                else:
                    print("No audio generated.")
            else:
                print(f"Generation failed: {result.get('error')}")
                print(f"Status: {result.get('status_message')}")
                
        except Exception:
            traceback.print_exc()

    # Generate Instrumental (Remove Vocals)
    print("Generating Instrumental Track...")
    generate_and_save("instrumental, backing track, no vocals", "accompaniment.wav")

    # Generate Vocals (Remove Instruments)
    print("Generating Vocals Track...")
    generate_and_save("vocals only, a cappella, no instruments", "vocals.wav")

    print("Separation complete.")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Separate music using ACE-STEP 1.5")
    parser.add_argument("--input", type=str, required=True, help="Path to input audio file")
    parser.add_argument("--output", type=str, default="output", help="Directory to save output files")
    parser.add_argument("--device", type=int, default=0, help="GPU device ID (default 0)")

    args = parser.parse_args()

    if not os.path.exists(args.input):
        print(f"Input file not found: {args.input}")
        sys.exit(1)

    separate_audio(args.input, args.output, args.device)
